{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      Vex Maze Solver\n#\tAuthor:       Yit-Meng Chin\n# \n# ------------------------------------------\n\n# Library imports\nimport time, math\n\n#region Variables\nvelo = 75\nwaitDelay = 0.5\nupdateDelay = 0.05\ntolerence = 2\n\n#Maze Info\nROW, COL = 6, 6\nSQUARE_SIZE = 35\nx0, y0 = 47.5, 30 #represents the position of the first grid square\ncx, cx = 0, 0 #represents the current coordinate\n\nxTorqueThesh = 2\nyTorqueThesh = 5\n\n#Degrees to mm\nchainLinkLen = 255.0/25\ndtmx = 12*chainLinkLen/360\ndtmy = 6*chainLinkLen/360\nmaxdtm = max(abs(dtmx), abs(dtmy))\n\n#Velocity Multipliers\n#This is for making the speed of the x and y axis the same despite different gear ratios\nvmx = abs(dtmy/maxdtm)\nvmy = abs(dtmx/maxdtm)\n\n#endregion\n\n#region Motor Setup\nxMotor.spin(FORWARD)\nyMotor1.spin(FORWARD)\nyMotor2.spin(FORWARD)\n\nxMotor.set_velocity(0, PERCENT)\nyMotor1.set_velocity(0, PERCENT)\nyMotor2.set_velocity(0, PERCENT)\n\nxMotor.set_stopping(HOLD)\nyMotor1.set_stopping(HOLD)\nyMotor2.set_stopping(HOLD)\n\n#endregion\n\n#region Function Def\ndef movey(velocity):\n    if velocity == 0:\n        yMotor1.stop()\n        yMotor2.stop()\n    else:\n        yMotor1.spin(FORWARD)\n        yMotor2.spin(FORWARD)\n        yMotor1.set_velocity(velocity*vmx, PERCENT)\n        yMotor2.set_velocity(velocity*vmx, PERCENT)\n\ndef movex(velocity):\n    if velocity == 0:\n        xMotor.stop()\n    else:\n        xMotor.spin(FORWARD)\n        xMotor.set_velocity(velocity*vmy, PERCENT)\n\ndef gety():\n    return yMotor1.position(DEGREES)*dtmx\n\ndef getx():\n    return xMotor.position(DEGREES)*dtmy\n\ndef collideY():\n    return yMotor1.torque(TorqueUnits.INLB) > yTorqueThesh\n\ndef collideX():\n    return xMotor.torque(TorqueUnits.INLB) > xTorqueThesh\n\ndef homeDevice():\n    # Homing Sequence\n    movey(-velo)\n    time.sleep(waitDelay)\n    while not collideY():\n        time.sleep(updateDelay)\n    movey(0)\n    yMotor1.set_position(0,DEGREES)\n    yMotor2.set_position(0,DEGREES)\n\n    movex(-velo)\n    time.sleep(waitDelay)\n    while not collideX():\n        time.sleep(updateDelay)\n    movex(0)\n    xMotor.set_position(0,DEGREES)\n\ndef goto(x,y):\n    dx = x - getx()\n    dy = y - gety()\n    while (abs(dx) > tolerence) or (abs(dy) > tolerence):\n        dx = x - getx()\n        dy = y - gety()\n        if abs(dx) > tolerence:\n            movex(math.copysign(velo, dx))\n        else:\n            movex(0)\n\n        if abs(dy) > tolerence:\n            movey(math.copysign(velo, dy))\n        else:\n            movey(0)\n\n#A possible future version of goto that would detect whether it has collided with something\n#while traveling and return to its inital position if so\ndef gotoCol(x,y):\n    ix, iy = getx(), gety() #initial x and y\n    tx, ty = x, y #Targeted x and y\n    collided = False\n\n    dx = tx - ix\n    dy = ty - iy\n\n    brain.timer.clear()\n    while (abs(dx) > tolerence) or (abs(dy) > tolerence):\n        dx = tx - getx()\n        dy = ty - gety()\n        if abs(dx) > tolerence:\n            movex(math.copysign(velo, dx))\n        else:\n            movex(0)\n\n        if abs(dy) > tolerence:\n            movey(math.copysign(velo, dy))\n        else:\n            movey(0)\n\n        if abs(dx) > 10 and abs(dy) > 10 and brain.timer.time(SECONDS) > waitDelay and (collideY() or collideX()):\n            brain.screen.clear_screen()\n            brain.screen.set_cursor(1,1)\n            brain.screen.print(\"x:\", collideX())\n            brain.screen.set_cursor(2,1)\n            brain.screen.print(\"y:\", collideY())\n            collided = True\n            tx, ty = ix, iy\n\n        time.sleep(updateDelay)\n    \n    return collided\n\ndef zeroMaze():\n    homeDevice()\n    goto(x0, y0)\n    xMotor.set_position(0,DEGREES)\n    yMotor1.set_position(0,DEGREES)\n    yMotor2.set_position(0,DEGREES)\n    global cx, cy\n    cx, cy = 0, 0\n\n#These two movement functions are created to prevent me from accidentally making diagonal moves.\ndef moveVerticalTile(numTiles):\n    global cy\n    cy = cy + numTiles\n    cy = min(cy, ROW-1)\n    cy = max(cy, 0)\n        \n    goto(cx*(SQUARE_SIZE + 2), cy*(SQUARE_SIZE + 1))\n\ndef moveHorizontalTile(numTiles):\n    global cx\n    cx = cx + numTiles\n    cx = min(cx, COL-1)\n    cx = max(cx, 0)\n        \n    goto(cx*(SQUARE_SIZE + 2), cy*(SQUARE_SIZE + 1))\n#endregion\n\n# homeDevice()\nzeroMaze()\ntime.sleep(waitDelay)\nmoveVerticalTile(5)\nmoveHorizontalTile(5)\nmoveVerticalTile(-5)\n\n\ntime.sleep(waitDelay)\ngotoCol(0,0)","textLanguage":"python","rconfig":[],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}