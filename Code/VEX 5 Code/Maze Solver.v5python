{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nyMotor = Motor(Ports.PORT11, GearSetting.RATIO_18_1, False)\nxMotor1 = Motor(Ports.PORT9, GearSetting.RATIO_18_1, True)\nxMotor2 = Motor(Ports.PORT21, GearSetting.RATIO_18_1, False)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      Vex Maze Solver\n#\tAuthor:       Yit-Meng Chin\n# \n# ------------------------------------------\n\n# Library imports\nimport time, math\n\n#region Variables\nvelo = 75\nwaitDelay = 0.5\nupdateDelay = 0.05\ntolerence = 1.5\n\n#Maze Info\nROW, COL = 6, 6\nSQUARE_SIZE = 35\nx0, y0 = 0, 0 #represents the position of the first grid square\ncx, cx = 0, 0 #represents the current coordinate\n\n#Degrees to mm\nchainLinkLen = 255.0/25\ndtmx = 12*chainLinkLen/360\ndtmy = 6*chainLinkLen/360\nmaxdtm = max(abs(dtmx), abs(dtmy))\n\n#Velocity Multipliers\n#This is for making the speed of the x and y axis the same despite different gear ratios\nvmx = abs(dtmy/maxdtm)\nvmy = abs(dtmx/maxdtm)\n\n#endregion\n\n#region Motor Setup\nyMotor.spin(FORWARD)\nxMotor1.spin(FORWARD)\nxMotor2.spin(FORWARD)\n\nyMotor.set_velocity(0, PERCENT)\nxMotor1.set_velocity(0, PERCENT)\nxMotor2.set_velocity(0, PERCENT)\n\nyMotor.set_stopping(HOLD)\nxMotor1.set_stopping(HOLD)\nxMotor2.set_stopping(HOLD)\n#endregion\n\n#region Function Def\ndef movex(velocity):\n    if velocity == 0:\n        xMotor1.stop()\n        xMotor2.stop()\n    else:\n        xMotor1.spin(FORWARD)\n        xMotor2.spin(FORWARD)\n        xMotor1.set_velocity(velocity*vmx, PERCENT)\n        xMotor2.set_velocity(velocity*vmx, PERCENT)\n\ndef movey(velocity):\n    if velocity == 0:\n        yMotor.stop()\n    else:\n        yMotor.spin(FORWARD)\n        yMotor.set_velocity(velocity*vmy, PERCENT)\n\ndef getx():\n    return xMotor1.position(DEGREES)*dtmx\n\ndef gety():\n    return yMotor.position(DEGREES)*dtmy\n\ndef collideX():\n    return xMotor1.current(CurrentUnits.AMP) > 2\n\ndef collideY():\n    return yMotor.current(CurrentUnits.AMP) > 1\n\ndef homeDevice():\n    # Homing Sequence\n    movex(-velo)\n    time.sleep(waitDelay)\n    while not collideX():\n        time.sleep(updateDelay)\n    movex(0)\n    xMotor1.set_position(0,DEGREES)\n    xMotor2.set_position(0,DEGREES)\n\n    movey(-velo)\n    time.sleep(waitDelay)\n    while not collideY():\n        time.sleep(updateDelay)\n    movey(0)\n    yMotor.set_position(0,DEGREES)\n\ndef goto(x,y):\n    dx = x - getx()\n    dy = y - gety()\n    while (abs(dx) > tolerence) or (abs(dy) > tolerence):\n        dx = x - getx()\n        dy = y - gety()\n        if abs(dx) > tolerence:\n            movex(math.copysign(velo, dx))\n        else:\n            movex(0)\n\n        if abs(dy) > tolerence:\n            movey(math.copysign(velo, dy))\n        else:\n            movey(0)\n\n#A possible future version of goto that would detect whether it has collided with something\n#while traveling and return to its inital position if so\ndef gotoCol(x,y):\n    ix, iy = getx(), gety() #initial x and y\n    tx, ty = x, y #Targeted x and y\n    collided = False\n\n    dx = tx - ix\n    dy = ty - iy\n    while (abs(dx) > tolerence) or (abs(dy) > tolerence):\n        if collideX() or collideY():\n            collided = True\n            tx, ty = ix, iy\n\n        dx = tx - getx()\n        dy = ty - gety()\n        if abs(dx) > tolerence:\n            movex(math.copysign(velo, dx))\n        else:\n            movex(0)\n\n        if abs(dy) > tolerence:\n            movey(math.copysign(velo, dy))\n        else:\n            movey(0)\n    \n    return collided\n\ndef zeroMaze():\n    homeDevice()\n    goto(x0, y0)\n    yMotor.set_position(0,DEGREES)\n    xMotor1.set_position(0,DEGREES)\n    xMotor2.set_position(0,DEGREES)\n    global cx, cy\n    cx, cy = 0, 0\n\n#These two movement functions are created to prevent me from accidentally making diagonal moves.\ndef moveVerticalTile(numTiles):\n    global cy\n    cy = cy + numTiles\n    cy = min(cy, ROW-1)\n    cy = max(cy, 0)\n        \n    goto(cx*SQUARE_SIZE, cy*SQUARE_SIZE)\n\ndef moveHorizontalTile(numTiles):\n    global cx\n    cx = cx + numTiles\n    cx = min(cx, COL-1)\n    cx = max(cx, 0)\n        \n    goto(cx*SQUARE_SIZE, cy*SQUARE_SIZE)\n#endregion\n\n","textLanguage":"python","rconfig":[{"port":[11],"name":"yMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[9],"name":"xMotor1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[21],"name":"xMotor2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}